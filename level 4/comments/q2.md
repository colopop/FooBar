# Level 4 Question 2: Guns and Guard Fights

You're in a room with a bad guy. You have a laser gun. How many ways can you shoot the bad guy? The catch is, the laser bounces off the walls and only goes a certain distance. So there are finite options and you have to be careful not to hit yourself! The input you get is the dimensions of the room, the locations of you and the bad guy (you're guaranteed not to be on walls or corners), and the distance your laser will go.

## "Reflection," not "Bouncing"

If you start to take a stab at the math of bouncing lasers, you'll realize that it's incredibly annoying. The distance calculation alone is way more of a pain than it needs to be; you have to get the distance to one wall, then independently get the distance back to the other wall, unless you hit the bad guy along the way, which means you need to be tracking your bounces... it's just annoying. But it gets a lot easier when you realize that, wait, bouncing off a wall is just a *reflection* -- and a reflection is an easy mathematical transformation. Basically, if you just pretend that instead of bouncing off the wall, you just continued straight *through* the wall into a mirrored version of the room (including a mirrored version of yourself and the bad guy), you end up with *the same result*, but easier math. And this logic works no matter how many walls you bounce off of! So suddenly, instead of you and a bad guy in a room, there are *infinite copies* of you and the bad guy in an infinite grid of weirdly reflected copies of the room you're in (in the code, I called them "frames"). And instead of needing to figure out if a particular vector will hit the bad guy, you can work backwards: pick any copy of the bad guy, get the vector from your location to him, and you have a vector that you know will hit the bad guy! At least as long as it doesn't hit you first or run against the distance limit. And this will give us *every* vector that can possibly hit the bad guy. 

## Getting to other frames

So we know they're out there, but how can we find them? Is there a way to generate bad guy locations, knowing we haven't missed any? It turns out there is. First, let's say that a "frame" is a copy of the original room in some orientation, with some coordinates relative to the original room. So for example, the original room is frame (0,0), hitting the right wall would take us to frame (1,0), and hitting the bottom left corner would take us to frame (-1,-1). Obviously, each frame has exactly one bad guy. So if we check every frame starting from the center and moving outwards, we'll never miss a bad guy. 

But how do we know the coordinates of the bad guy? Well, let's start small. If we hit the left wall, we enter frame (-1,0), a reflection of the room across the y-axis. When you reflect across the y-axis, you invert the x-coordinate and leave the y the same. So if the badguy is at position (x,y) in the room, his reflection in frame (-1,0) will be (-x,y). Similarly, if we hit the bottom wall, we'd be aiming for (x,-y). 

So now imagine we hit the opposite side of that frame, too. We have to reflect again, right? But wait -- if we reflect twice, we just get the original room back, translated two frames! So that bad guy's position in frame (-2,0) will be (x - 2 * room_width, y). And there's clearly a pattern here; every even frame will end up being a translation of (0,0), and every odd frame will end up being a translation of (-1,0). Obviously this pattern applies in the y-direction as well. So to express this in something we can compute, the coordinates (x,y) in frame (0,0) map to coordinates (x + n * room_width, y) in frame (n,0) if n is even (translating the original room n frames), or coordinates (-x + (n+1) * room_width, y) if n is odd (translating the first frame to the left n+1 frames). Finding the coordinates in frame (0,n) is similar. Diagonals aren't really more complicated -- since each reflection only affects one coordinate at once, you can get the bad guy's position in, say (-3,2) by composing the x-coordinate from (-3,0) with the y-coordinate from (0,2).

## Pruning our options

OK, we can generate as many bad guy vectors as we want. How many do we want? Well, the laser has a maximum distance it can travel, so we don't need to check frames that are too far away to possibly shoot. How many frames is that? For an upper bound, let's reverse the equation we got in the last section. We'll start with the fact that we're in frame (n,0) and our x-coordinate is our max_distance, and we'll try to deduce n. Our base x-coordinate in (0,0) has to be our location, since that's where we're shooting from. It turns out our frame n is no larger than (max_distance + starting_location)/width. (The exact value depends on whether n is even or odd, but we can just pick the larger one to be safe. A similar argument applies to find the maximum frame we go to vertically. And diagonally, we'll never exceed the maximum frame in either direction (guaranteed by the triangle inequality). Awesome: we can just loop through all of these frames and we go through every possible vector in `O((max_distance + starting_location)^2/(width*height))`. 

We do need to do some more pruning though. First, the easy part: some vectors are redundant. you can shoot two copies of the bad guy with one angle. This is easy to get rid of efficiently; we can reduce a vector to lowest form very efficiently and store it in a hash table to allow no duplicates. Python's `set` object is well-suited for the task.

The second, more difficult challenge is to remove all the vectors that bounce around and hit us before they hit the bad guy. For starters, we should keep track of all the vectors that hit us in a different `set`. Then, after collecting all the vectors, we should take the *intersection* of the vectors that hit the bad guy and the vectors that hit us. Anything that hits us that isn't in the intersection, we can discard; anything that hits the bad guy that isn't in the intersection, we can accept with no further thought.

Now at this point, a decision we made earlier comes back to bite us. When we stored vectors in only their smallest form, we lost information. It was necessary for efficiency, but it does mean we can't simply determine whether the beam hits us or the bad guy first in constant time (if we had the original vectors, we could do it by comparing the magnitudes). We have to actually simulate shooting a laser and see who it hits first. This isn't as bad as it seems; in the worst case, this will add `O(number of vectors * max_distance)`, if *every* solution we found hits both us and the bad guy; however, my intuition is that the closer this is to the case, the fewer solutions we actually found relative to the area we searched (that is, `number of vectors` is not the same as `(max_distance + starting_location)^2/(width*height)`. I haven't proven it, but I didn't run into any performance issues.

Regardless, that's all we need to do! In the actual submission, I overestimated on some parameters, since I was more concerned with accuracy than performance. But we could probably squeeze out a little more performance if we tried.
