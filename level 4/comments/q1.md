# Level 4 Question 1: Bunnies on a Graph

I think this problem might be NP-hard. The solution I got certainly doesn't have polynomial complexity, and I'm not sure how to make it work much better. 

The problem is something like this: you have a room with several points of interest. There's the entrance, where you start. There's this exit, which you have to reach in a certain amount of time. And there are up to 5 bunnies, which you want to reach to pick up. You can reach any point from any other point, but there are different time costs associated with traveling between points. Those costs can be negative (you reach a terminal or something and give yourself more time). The goal is to pick up as many bunnies as possible while still being able to reach the exit inside the time limit.

This is obviously a graph problem. The first thing to notice is that it doesn't matter how many times we touch a given node or traverse a given edge. It only matters which nodes we've touched at least once in the end. So to make things easier, we can run a shortest-path algorithm (my implementation uses Bellman-Ford) and store the *lowest-cost* path from each node to each other node, and work with those paths instead. (Note that if there is a negative cycle in the graph, we can build up as much time as we want and eventually rescue all bunnies. So we can check for a negative cycle here and jump right to the solution if there is one.)

Let's consider one possible path through a graph. We start at the entrance, then take the cheapest path to bunny 1, then take the cheapest path to bunny 2, and so on, until we take the cheapest path from the last bunny we visited to the exit. If we add up the costs of all those paths and it's less than or equal to the time limit, then great -- we know we can rescue all the bunnies we visited, since we constructed a valid path. However, if the cost is greater than the time limit, we might be in trouble. Since we always took the cheapest possible route, there can't exist a better way to go from bunny 1 to bunny 2 to bunny 3 etc. (If there did exist a shorter path, then at least one path between two consecutive bunnies would have to be shorter, which contradicts our "cheapest path" assumption.) So if that still isn't good enough, then we know we definitely can't rescue that set of bunnies... *in that order*. We can easily imagine a scenario where the path from bunny 2 to bunny 3 includes bunny 5, so going back to bunny 5 at the end is redundant and potentially adds unnecessarily to the cost of the path.

But since we know how to get the optimal path for a particular ordering of a set of bunnies, all we need to do is check every ordering of every subset. This is obviously a problem that grows very quickly. A set of size `n` has `2^n` subsets, and a string of length `m` has `m!` orderings. We can add some optimization by checking the subsets from larger to smaller and stopping once we have a solution, but this doesn't affect the asymptotic complexity. However, since these graphs get no larger than 7 nodes (and really only 5 nodes affect the complexity since the entrance and exit are always in the set and always in the same place in the ordering) this is a good enough solution.

Sidenote: I found out after submission that `itertools.permutations` takes an optional second argument, specifying the subset size. This would obviously make for slightly cleaner code than the posted solution. 
