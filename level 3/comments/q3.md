# Level 3 Question 3: Fuel Injection Perfection

I've been trying to come up with other names for each problem to make the solutions more difficult to search for, but I found it hard to characterize this one in a pithy way. The basic idea is you get a number and you can do one of three operations to it: add one, subtract one, or divide it by two (if it's even). The question is how many times do you need to do one of these operations to your input before you reach 1. 

I haven't really been able to prove to my own satisfaction the correctness of the algorithm here. The idea behind it is this: if you have an even number, your best move is always to divide it by 2. If your number is congruent to 3 mod 4, then you add 1. If your number is congruent to 1 mod 4, you subtract 1. The vague reasoning is that if you divide a number by 2, you bitshift it to the right by 1 -- in an ideal world, you'd divide by 2 every time and reach the end in lg(n) steps. If the number is congruent to 1 mod 4, then its bits look something like 1......01. So subtracting 1 turns that into 1......00, which lets you do more division by 2. If it's congruent to 3 mod 4, then your number ends up looking like 1......11. So in this case the way to get to 1.....00 is to *add* 1. Of course, this might sometimes add a digit to the number as well -- but if this is the case, adding one brings you to a power of 2, which allows you to divide by 2 the entire rest of the way down to 1. (The only time this doesn't work is with the number 3. I think this is because 3 is just of the form 11, not 1.....11.) 

Hopefully that explanation is intuitive enough -- it passes all test cases and I'm reasonably confident it holds in general. I wish I could come up with a formal proof. Induction seems promising but I haven't quite been able to get it to work.
